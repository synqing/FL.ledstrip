#include <Arduino.h>
#include <FastLED.h>
#include <Wire.h>
#include "M5UnitScroll.h"

// Configuration
#define NUM_LEDS 64      // 8x8 matrix
#define DATA_PIN 14      // Changed to GPIO 14
#define POWER_PIN 5
#define BRIGHTNESS 48        // Reduced from 96 to be easier on the eyes
#define MAX_BRIGHTNESS 96    // Maximum allowed brightness
#define MIN_BRIGHTNESS 8     // Minimum visible brightness
#define LED_TYPE WS2812
#define COLOR_ORDER GRB

// I2C for M5Stack Scroll
#define I2C_SDA 35
#define I2C_SCL 36
#define SCROLL_ADDR 0x40    // M5Stack Scroll I2C address

// M5Stack Scroll instance
M5UnitScroll scroll;
bool encoderConnected = false;
int16_t lastEncoderValue = 0;
bool lastButtonState = false;

// No physical button - will use M5Stack Scroll encoder wheel

// Global LED array
CRGB leds[NUM_LEDS];
CRGB transitionBuffer[NUM_LEDS];  // For smooth transitions

// Strip mapping arrays for spatial effects
uint8_t angles[NUM_LEDS];
uint8_t radii[NUM_LEDS];

// Effect parameters
uint8_t gHue = 0;
uint8_t currentEffect = 0;
uint8_t previousEffect = 0;
uint32_t lastButtonPress = 0;
uint8_t fadeAmount = 20;
uint8_t paletteSpeed = 10;
uint8_t currentBrightness = BRIGHTNESS;

// Palette Mode
bool paletteMode = false;
uint32_t lastPaletteModeChange = 0;
const uint32_t PALETTE_MODE_DURATION = 3000; // 3 seconds per palette in palette mode

// Transition parameters
bool inTransition = false;
uint32_t transitionStart = 0;
uint32_t transitionDuration = 1000;  // 1 second transitions
float transitionProgress = 0.0f;

// Palette management
CRGBPalette16 currentPalette;
CRGBPalette16 targetPalette;
uint8_t currentPaletteIndex = 0;

// Include palette definitions
#include "Palettes.h"

// M5Stack Scroll initialization
void initM5Scroll() {
    Serial.print("Initializing M5Stack Scroll... ");
    
    // Initialize with our I2C pins
    encoderConnected = scroll.begin(&Wire, SCROLL_ADDR, I2C_SDA, I2C_SCL, 400000U);
    
    if (encoderConnected) {
        Serial.println("CONNECTED!");
        
        // Get firmware version
        uint8_t fw_version = scroll.getFirmwareVersion();
        Serial.print("Firmware version: ");
        Serial.println(fw_version);
        
        // Reset encoder to 0
        scroll.resetEncoder();
        
        // Set LED to green
        scroll.setLEDColor(0x00FF00);  // Green
        
        // Visual feedback - gentle green pulse
        for (int brightness = 0; brightness < 64; brightness += 4) {
            fill_solid(leds, NUM_LEDS, CRGB(0, brightness, 0));
            FastLED.show();
            delay(10);
        }
        for (int brightness = 64; brightness >= 0; brightness -= 4) {
            fill_solid(leds, NUM_LEDS, CRGB(0, brightness, 0));
            FastLED.show();
            delay(10);
        }
        FastLED.clear(true);
        
        // Set scroll LED to blue (ready)
        scroll.setLEDColor(0x0000FF);  // Blue
        
        Serial.println("M5Stack Scroll ready for input");
    } else {
        Serial.println("NOT FOUND!");
        Serial.println("Running in auto-mode");
        
        // Visual feedback - gentle red fade
        for (int brightness = 0; brightness < 48; brightness += 4) {
            fill_solid(leds, NUM_LEDS, CRGB(brightness, 0, 0));
            FastLED.show();
            delay(20);
        }
        delay(200);
        for (int brightness = 48; brightness >= 0; brightness -= 4) {
            fill_solid(leds, NUM_LEDS, CRGB(brightness, 0, 0));
            FastLED.show();
            delay(20);
        }
        FastLED.clear(true);
    }
}

// Effect function pointer type
typedef void (*EffectFunction)();

// Initialize strip mapping for 8x8 matrix effects
void initializeStripMapping() {
    // Map LEDs to angles and radii for circular effects on 8x8 grid
    for (uint16_t i = 0; i < NUM_LEDS; i++) {
        uint8_t x = i % 8;  // X coordinate (0-7)
        uint8_t y = i / 8;  // Y coordinate (0-7)
        
        // Calculate angle from center (3.5, 3.5)
        float dx = x - 3.5f;
        float dy = y - 3.5f;
        float angle = atan2(dy, dx) + PI;  // 0 to 2*PI
        angles[i] = (angle / (2 * PI)) * 255;
        
        // Calculate radius from center
        float radius = sqrt(dx*dx + dy*dy) / 5.657f;  // Max radius is ~5.657 (corner to center)
        radii[i] = radius * 255;
    }
}

// ============== BASIC EFFECTS ==============

void confetti() {
    fadeToBlackBy(leds, NUM_LEDS, 10);
    int pos = random16(NUM_LEDS);
    leds[pos] += ColorFromPalette(currentPalette, gHue + random8(64), 255);
}

void sinelon() {
    fadeToBlackBy(leds, NUM_LEDS, 20);
    int pos = beatsin16(13, 0, NUM_LEDS-1);
    leds[pos] += ColorFromPalette(currentPalette, gHue, 192);
}

void juggle() {
    fadeToBlackBy(leds, NUM_LEDS, 20);
    uint8_t dothue = 0;
    for(int i = 0; i < 8; i++) {
        leds[beatsin16(i+7, 0, NUM_LEDS-1)] |= ColorFromPalette(currentPalette, dothue, 255);
        dothue += 32;
    }
}

void bpm() {
    uint8_t BeatsPerMinute = 62;
    uint8_t beat = beatsin8(BeatsPerMinute, 64, 255);
    for(int i = 0; i < NUM_LEDS; i++) {
        leds[i] = ColorFromPalette(currentPalette, gHue+(i*2), beat-gHue+(i*10));
    }
}

// ============== ADVANCED WAVE EFFECTS ==============

void waveEffect() {
    static uint16_t wavePosition = 0;
    
    fadeToBlackBy(leds, NUM_LEDS, fadeAmount);
    
    uint16_t waveSpeed = map(paletteSpeed, 1, 50, 100, 10);
    wavePosition += waveSpeed;
    
    for (uint16_t i = 0; i < NUM_LEDS; i++) {
        uint8_t brightness = sin8((i * 10) + (wavePosition >> 4));
        uint8_t colorIndex = angles[i] + (wavePosition >> 6);
        
        CRGB color = ColorFromPalette(currentPalette, colorIndex, brightness);
        leds[i] = color;
    }
}

void rippleEffect() {
    static struct {
        float center;
        float radius;
        float speed;
        uint8_t hue;
        bool active;
    } ripples[5];
    
    fadeToBlackBy(leds, NUM_LEDS, fadeAmount);
    
    // Spawn new ripples
    if (random8() < 20) {
        for (uint8_t i = 0; i < 5; i++) {
            if (!ripples[i].active) {
                ripples[i].center = random16(NUM_LEDS);
                ripples[i].radius = 0;
                ripples[i].speed = 0.5f + (random8() / 255.0f) * 2.0f;
                ripples[i].hue = random8();
                ripples[i].active = true;
                break;
            }
        }
    }
    
    // Update and render ripples
    for (uint8_t r = 0; r < 5; r++) {
        if (!ripples[r].active) continue;
        
        ripples[r].radius += ripples[r].speed * (paletteSpeed / 10.0f);
        
        if (ripples[r].radius > NUM_LEDS) {
            ripples[r].active = false;
            continue;
        }
        
        for (uint16_t i = 0; i < NUM_LEDS; i++) {
            float distance = abs((float)i - ripples[r].center);
            float wavePos = distance - ripples[r].radius;
            
            if (abs(wavePos) < 5.0f) {
                uint8_t brightness = 255 - (abs(wavePos) * 51);
                brightness = (brightness * (NUM_LEDS - ripples[r].radius)) / NUM_LEDS;
                
                CRGB color = ColorFromPalette(currentPalette, ripples[r].hue + distance * 4, brightness);
                leds[i] += color;
            }
        }
    }
}

void interferenceEffect() {
    static float wave1Phase = 0;
    static float wave2Phase = 0;
    
    fadeToBlackBy(leds, NUM_LEDS, fadeAmount);
    
    wave1Phase += paletteSpeed / 20.0f;
    wave2Phase -= paletteSpeed / 30.0f;
    
    for (uint16_t i = 0; i < NUM_LEDS; i++) {
        float pos = (float)i / NUM_LEDS;
        
        float wave1 = sin(pos * PI * 4 + wave1Phase) * 127 + 128;
        float wave2 = sin(pos * PI * 6 + wave2Phase) * 127 + 128;
        
        float interference = (wave1 + wave2) / 2.0f;
        uint8_t brightness = interference;
        
        uint8_t hue = (uint8_t)(wave1Phase * 20) + angles[i];
        
        CRGB color = ColorFromPalette(currentPalette, hue, brightness);
        leds[i] = color;
    }
}

// ============== MATHEMATICAL PATTERNS ==============

void fibonacciSpiral() {
    static float spiralPhase = 0;
    
    fadeToBlackBy(leds, NUM_LEDS, fadeAmount);
    spiralPhase += paletteSpeed / 50.0f;
    
    // Fibonacci sequence positions
    int fib[] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};
    
    for (int f = 0; f < 10; f++) {
        int pos = (fib[f] + (int)spiralPhase) % NUM_LEDS;
        uint8_t hue = f * 25 + gHue;
        uint8_t brightness = 255 - (f * 20);
        
        // Draw with falloff
        for (int i = -3; i <= 3; i++) {
            int ledPos = (pos + i + NUM_LEDS) % NUM_LEDS;
            uint8_t fadeBrightness = brightness - (abs(i) * 60);
            leds[ledPos] += ColorFromPalette(currentPalette, hue, fadeBrightness);
        }
    }
}

void kaleidoscope() {
    static uint16_t offset = 0;
    offset += paletteSpeed;
    
    // Create symmetrical patterns
    for (int i = 0; i < NUM_LEDS / 2; i++) {
        uint8_t hue = sin8(i * 10 + offset) + gHue;
        uint8_t brightness = sin8(i * 15 + offset * 2);
        
        CRGB color = ColorFromPalette(currentPalette, hue, brightness);
        
        leds[i] = color;
        leds[NUM_LEDS - 1 - i] = color;  // Mirror
    }
}

void plasma() {
    static uint16_t time = 0;
    time += paletteSpeed;
    
    for (int i = 0; i < NUM_LEDS; i++) {
        float v1 = sin((float)i / 8.0f + time / 100.0f);
        float v2 = sin((float)i / 5.0f - time / 150.0f);
        float v3 = sin((float)i / 3.0f + time / 200.0f);
        
        uint8_t hue = (uint8_t)((v1 + v2 + v3) * 42.5f + 127.5f) + gHue;
        uint8_t brightness = (uint8_t)((v1 + v2) * 63.75f + 191.25f);
        
        leds[i] = ColorFromPalette(currentPalette, hue, brightness);
    }
}

// ============== NATURE-INSPIRED EFFECTS ==============

void fire() {
    static byte heat[NUM_LEDS];
    
    // Cool down every cell a little
    for(int i = 0; i < NUM_LEDS; i++) {
        heat[i] = qsub8(heat[i], random8(0, ((55 * 10) / NUM_LEDS) + 2));
    }
    
    // Heat from each cell drifts up and diffuses
    for(int k = NUM_LEDS - 1; k >= 2; k--) {
        heat[k] = (heat[k - 1] + heat[k - 2] + heat[k - 2]) / 3;
    }
    
    // Randomly ignite new sparks
    if(random8() < 120) {
        int y = random8(7);
        heat[y] = qadd8(heat[y], random8(160, 255));
    }
    
    // Map heat to LED colors using fire palette from current palette
    for(int j = 0; j < NUM_LEDS; j++) {
        // Scale heat value to palette index
        uint8_t colorIndex = scale8(heat[j], 240);
        CRGB color = ColorFromPalette(currentPalette, colorIndex);
        leds[j] = color;
    }
}

void ocean() {
    static uint16_t waterOffset = 0;
    waterOffset += paletteSpeed / 2;
    
    for (int i = 0; i < NUM_LEDS; i++) {
        // Create wave-like motion
        uint8_t wave1 = sin8((i * 10) + waterOffset);
        uint8_t wave2 = sin8((i * 7) - waterOffset * 2);
        uint8_t combinedWave = (wave1 + wave2) / 2;
        
        // Map to palette
        uint8_t colorIndex = combinedWave + angles[i];
        uint8_t brightness = 100 + (combinedWave >> 1);
        
        leds[i] = ColorFromPalette(currentPalette, colorIndex, brightness);
    }
}

// ============== PALETTE MODE ==============

void paletteWave() {
    // Special effect that showcases the current palette
    static uint16_t paletteOffset = 0;
    paletteOffset += paletteSpeed * 2;
    
    // Create a wave that flows through the palette colors
    for (int i = 0; i < NUM_LEDS; i++) {
        // Use multiple sine waves for complex patterns
        uint8_t wave1 = sin8((i * 10) + (paletteOffset >> 2));
        uint8_t wave2 = sin8((i * 7) - (paletteOffset >> 3));
        uint8_t combinedWave = (wave1 + wave2) / 2;
        
        // Map position and wave to palette index
        uint8_t colorIndex = angles[i] + (paletteOffset >> 4) + (combinedWave >> 2);
        uint8_t brightness = 150 + (combinedWave >> 1);  // Keep it bright to show colors
        
        leds[i] = ColorFromPalette(currentPalette, colorIndex, brightness);
    }
}

// ============== TRANSITION SYSTEM ==============

void startTransition(uint8_t newEffect) {
    if (newEffect == currentEffect) return;
    
    // Save current LED state
    for (int i = 0; i < NUM_LEDS; i++) {
        transitionBuffer[i] = leds[i];
    }
    
    previousEffect = currentEffect;
    currentEffect = newEffect;
    inTransition = true;
    transitionStart = millis();
    transitionProgress = 0.0f;
}

void updateTransition() {
    if (!inTransition) return;
    
    uint32_t elapsed = millis() - transitionStart;
    transitionProgress = (float)elapsed / transitionDuration;
    
    if (transitionProgress >= 1.0f) {
        transitionProgress = 1.0f;
        inTransition = false;
    }
    
    // Smooth easing function (ease-in-out)
    float t = transitionProgress;
    float eased = t < 0.5f 
        ? 2 * t * t 
        : 1 - pow(-2 * t + 2, 2) / 2;
    
    // Blend between old and new effect
    for (int i = 0; i < NUM_LEDS; i++) {
        CRGB oldColor = transitionBuffer[i];
        CRGB newColor = leds[i];
        
        leds[i] = blend(oldColor, newColor, eased * 255);
    }
}

// Array of effects
struct Effect {
    const char* name;
    EffectFunction function;
};

Effect effects[] = {
    // Basic effects (NO RAINBOWS!) - ALL using palettes now
    {"Confetti", confetti},
    {"Sinelon", sinelon},
    {"Juggle", juggle},
    {"BPM", bpm},
    
    // Wave effects
    {"Wave", waveEffect},
    {"Ripple", rippleEffect},
    {"Interference", interferenceEffect},
    
    // Mathematical patterns
    {"Fibonacci", fibonacciSpiral},
    {"Kaleidoscope", kaleidoscope},
    {"Plasma", plasma},
    
    // Nature effects
    {"Fire", fire},
    {"Ocean", ocean}
};

const uint8_t NUM_EFFECTS = sizeof(effects) / sizeof(effects[0]);

void setup() {
    // Initialize serial
    Serial.begin(115200);
    delay(1000);
    
    Serial.println("\n=== Light Crystals Matrix 8x8 ===");
    Serial.println("Board: ESP32-S3 (4MB Flash)");
    Serial.print("LED Pin: GPIO");
    Serial.println(DATA_PIN);
    Serial.print("LEDs: ");
    Serial.println(NUM_LEDS);
    Serial.print("Effects: ");
    Serial.println(NUM_EFFECTS);
    Serial.println("Control: M5Stack Scroll I2C");
    Serial.print("I2C: SDA=GPIO");
    Serial.print(I2C_SDA);
    Serial.print(" SCL=GPIO");
    Serial.println(I2C_SCL);
    
    // Initialize power pin first
    pinMode(POWER_PIN, OUTPUT);
    digitalWrite(POWER_PIN, HIGH);
    delay(100); // Let power stabilize
    
    // Initialize LEDs
    FastLED.addLeds<LED_TYPE, DATA_PIN, COLOR_ORDER>(leds, NUM_LEDS);
    FastLED.setBrightness(BRIGHTNESS);
    FastLED.setCorrection(TypicalLEDStrip);
    
    // Clear LEDs before I2C init
    FastLED.clear(true);
    
    // Initialize M5Stack Scroll with visual feedback
    // The library handles Wire.begin internally
    initM5Scroll();
    
    // Initialize strip mapping
    initializeStripMapping();
    
    // Initialize palette
    currentPaletteIndex = 0;
    currentPalette = CRGBPalette16(gGradientPalettes[currentPaletteIndex]);
    targetPalette = currentPalette;
    
    // Clear LEDs
    FastLED.clear(true);
    
    // Gentle startup animation - fade in from edges
    Serial.println("Starting gentle boot sequence...");
    for (int radius = 4; radius >= 0; radius--) {
        for (int i = 0; i < NUM_LEDS; i++) {
            uint8_t x = i % 8;
            uint8_t y = i / 8;
            int distance = max(abs(x - 3.5), abs(y - 3.5));
            if (distance >= radius) {
                leds[i] = CHSV(160 + (radius * 10), 200, 32); // Soft blue-cyan gradient
            }
        }
        FastLED.show();
        delay(100);
    }
    
    // Fade out
    for (int brightness = 32; brightness >= 0; brightness -= 2) {
        FastLED.setBrightness(brightness);
        FastLED.show();
        delay(20);
    }
    
    // Restore brightness
    FastLED.setBrightness(currentBrightness);
    FastLED.clear(true);
    
    Serial.println("=== Setup Complete ===\n");
}

void autoRotateEffects() {
    // Only auto-rotate if encoder is not connected
    if (encoderConnected) return;
    
    static uint32_t lastEffectChange = 0;
    
    if (millis() - lastEffectChange > 10000) {  // 10 seconds per effect
        lastEffectChange = millis();
        
        // Start transition to next effect
        uint8_t nextEffect = (currentEffect + 1) % NUM_EFFECTS;
        startTransition(nextEffect);
        
        Serial.print("Auto-transitioning to: ");
        Serial.println(effects[nextEffect].name);
    }
}

void updatePalette() {
    // Smoothly blend between palettes
    static uint32_t lastPaletteChange = 0;
    
    // In palette mode, cycle faster through all palettes
    uint32_t changeInterval = paletteMode ? PALETTE_MODE_DURATION : 5000;
    
    if (millis() - lastPaletteChange > changeInterval) {
        lastPaletteChange = millis();
        currentPaletteIndex = (currentPaletteIndex + 1) % gGradientPaletteCount;
        targetPalette = CRGBPalette16(gGradientPalettes[currentPaletteIndex]);
        
        if (paletteMode) {
            Serial.print("Palette Mode - Showing: ");
            Serial.print(currentPaletteIndex);
            Serial.print("/");
            Serial.println(gGradientPaletteCount);
        }
    }
    
    // Blend towards target palette
    nblendPaletteTowardPalette(currentPalette, targetPalette, 24);
}

void handleEncoderInput() {
    if (!encoderConnected) return;
    
    // Check if device is still connected
    if (!scroll.getDevStatus()) {
        encoderConnected = false;
        Serial.println("M5Stack Scroll disconnected!");
        scroll.setLEDColor(0xFF0000);  // Red for error
        return;
    }
    
    // Check button state first
    bool buttonPressed = scroll.getButtonStatus();
    
    // Read encoder value
    int16_t currentValue = scroll.getEncoderValue();
    int16_t delta = currentValue - lastEncoderValue;
    
    if (delta != 0) {
        lastEncoderValue = currentValue;
        
        if (buttonPressed) {
            // Button held - adjust brightness
            if (delta > 0) {
                // Increase brightness
                currentBrightness = min(currentBrightness + 4, MAX_BRIGHTNESS);
            } else {
                // Decrease brightness
                currentBrightness = max(currentBrightness - 4, MIN_BRIGHTNESS);
            }
            FastLED.setBrightness(currentBrightness);
            
            // Show brightness level on scroll LED (dimmer = more red, brighter = more green)
            uint8_t greenLevel = map(currentBrightness, MIN_BRIGHTNESS, MAX_BRIGHTNESS, 0, 255);
            uint8_t redLevel = 255 - greenLevel;
            uint32_t color = (redLevel << 16) | (greenLevel << 8);
            scroll.setLEDColor(color);
            
            Serial.print("Brightness: ");
            Serial.print(currentBrightness);
            Serial.print("/");
            Serial.println(MAX_BRIGHTNESS);
        } else {
            // Normal rotation - change effects
            scroll.setLEDColor(0xFFFFFF);  // White flash
            
            if (delta > 0) {
                // Clockwise - next effect
                uint8_t nextEffect = (currentEffect + 1) % NUM_EFFECTS;
                startTransition(nextEffect);
                Serial.print("Encoder -> Effect: ");
                Serial.println(effects[nextEffect].name);
            } else {
                // Counter-clockwise - previous effect
                uint8_t prevEffect = (currentEffect == 0) ? NUM_EFFECTS - 1 : currentEffect - 1;
                startTransition(prevEffect);
                Serial.print("Encoder <- Effect: ");
                Serial.println(effects[prevEffect].name);
            }
            
            // Return LED to mode color
            delay(50);
            scroll.setLEDColor(paletteMode ? 0xFF00FF : 0x0000FF);
        }
    }
    
    // Handle button press/release for mode toggle
    if (!buttonPressed && lastButtonState) {
        // Button just released - only toggle if we didn't adjust brightness
        if (delta == 0) {
            paletteMode = !paletteMode;
            
            if (paletteMode) {
                Serial.println("\n=== PALETTE MODE ACTIVATED ===");
                Serial.println("Cycling through all palettes...");
                currentPaletteIndex = 0;
                scroll.setLEDColor(0xFF00FF);  // Magenta for palette mode
            } else {
                Serial.println("\n=== EFFECT MODE ACTIVATED ===");
                scroll.setLEDColor(0x0000FF);  // Blue for effect mode
            }
        }
    }
    lastButtonState = buttonPressed;
}

void loop() {
    // Check for palette mode toggle (temporary - will be controlled by M5Stack Scroll)
    static uint32_t lastModeToggle = 0;
    if (millis() - lastModeToggle > 30000) {  // Toggle palette mode every 30 seconds
        lastModeToggle = millis();
        paletteMode = !paletteMode;
        
        if (paletteMode) {
            Serial.println("\n=== PALETTE MODE ACTIVATED ===");
            Serial.println("Cycling through all palettes...");
            currentPaletteIndex = 0;  // Start from first palette
        } else {
            Serial.println("\n=== EFFECT MODE ACTIVATED ===");
        }
    }
    
    // Update palette blending
    updatePalette();
    
    if (paletteMode) {
        // In palette mode, only show the palette wave effect
        paletteWave();
    } else {
        // Normal effect mode
        autoRotateEffects();
        
        // If not in transition, run current effect
        if (!inTransition) {
            effects[currentEffect].function();
        } else {
            // Run the new effect to generate target colors
            effects[currentEffect].function();
            // Then apply transition blending
            updateTransition();
        }
    }
    
    // Show the LEDs
    FastLED.show();
    
    // Advance the global hue
    EVERY_N_MILLISECONDS(20) {
        gHue++;
    }
    
    // Status every 5 seconds
    EVERY_N_SECONDS(5) {
        Serial.print("Effect: ");
        Serial.print(effects[currentEffect].name);
        Serial.print(", Palette: ");
        Serial.print(currentPaletteIndex);
        Serial.print(", Free heap: ");
        Serial.print(ESP.getFreeHeap());
        Serial.println(" bytes");
    }
    
    // Frame rate
    delay(1000/120); // 120 FPS
}